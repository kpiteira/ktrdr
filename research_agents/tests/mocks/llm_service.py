"""
Mock LLM service for testing

Provides a clean, stateful mock that implements the LLMService interface.
"""

from typing import Dict, Any, List
from ...services.interfaces import LLMService


class MockLLMService(LLMService):
    """Mock LLM service for testing"""
    
    def __init__(self):
        self.call_history: List[Dict[str, Any]] = []
        self.responses: Dict[str, Any] = {}
        self.call_count = 0
        self.errors: Dict[str, Exception] = {}
    
    def set_response(self, method: str, response: Any) -> None:
        """Set predefined response for a method"""
        self.responses[method] = response
    
    def set_error(self, method: str, error: Exception) -> None:
        """Set error to raise for a method"""
        self.errors[method] = error
    
    def clear_history(self) -> None:
        """Clear call history"""
        self.call_history.clear()
        self.call_count = 0
    
    async def generate_hypothesis(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Generate a single hypothesis (mock)"""
        self.call_count += 1
        self.call_history.append({
            "method": "generate_hypothesis",
            "context": context,
            "call_number": self.call_count
        })
        
        # Check for error injection
        if "generate_hypothesis" in self.errors:
            raise self.errors["generate_hypothesis"]
        
        # Return predefined response or default
        return self.responses.get("generate_hypothesis", {
            "hypothesis": "Mock hypothesis for testing",
            "experiment_type": "momentum_strategy",
            "confidence": 0.8,
            "rationale": "Generated by mock LLM service for testing",
            "source": "mock_llm_service"
        })
    
    async def generate_hypotheses(self, context: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate multiple hypotheses (mock)"""
        self.call_count += 1
        self.call_history.append({
            "method": "generate_hypotheses",
            "context": context,
            "call_number": self.call_count
        })
        
        # Check for error injection
        if "generate_hypotheses" in self.errors:
            raise self.errors["generate_hypotheses"]
        
        # Return predefined response or default
        if "generate_hypotheses" in self.responses:
            return self.responses["generate_hypotheses"]
        
        # Default response - multiple hypotheses
        return [
            {
                "hypothesis": "Mock momentum strategy with adaptive parameters",
                "experiment_type": "momentum_strategy",
                "confidence": 0.8,
                "rationale": "Mock momentum strategy for testing",
                "source": "mock_llm_service"
            },
            {
                "hypothesis": "Mock mean reversion strategy with volatility filters",
                "experiment_type": "mean_reversion", 
                "confidence": 0.7,
                "rationale": "Mock mean reversion strategy for testing",
                "source": "mock_llm_service"
            },
            {
                "hypothesis": "Mock pattern recognition with neural networks",
                "experiment_type": "pattern_recognition",
                "confidence": 0.9,
                "rationale": "Mock pattern recognition for testing",
                "source": "mock_llm_service"
            }
        ]
    
    def assert_called_with(self, method: str, expected_context: Dict[str, Any]) -> None:
        """Assert method was called with expected context"""
        calls = [call for call in self.call_history if call["method"] == method]
        assert len(calls) > 0, f"Method {method} was not called"
        
        latest_call = calls[-1]
        assert latest_call["context"] == expected_context, f"Method {method} called with wrong context"
    
    def assert_called_once(self, method: str) -> None:
        """Assert method was called exactly once"""
        calls = [call for call in self.call_history if call["method"] == method]
        assert len(calls) == 1, f"Method {method} was called {len(calls)} times, expected 1"
    
    def assert_not_called(self, method: str) -> None:
        """Assert method was not called"""
        calls = [call for call in self.call_history if call["method"] == method]
        assert len(calls) == 0, f"Method {method} was called {len(calls)} times, expected 0"
    
    def get_call_count(self, method: str) -> int:
        """Get number of times method was called"""
        return len([call for call in self.call_history if call["method"] == method])
    
    def get_last_call(self, method: str) -> Dict[str, Any]:
        """Get the last call for a method"""
        calls = [call for call in self.call_history if call["method"] == method]
        if not calls:
            raise AssertionError(f"Method {method} was never called")
        return calls[-1]