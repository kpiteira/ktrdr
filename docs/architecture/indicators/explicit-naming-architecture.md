# Architecture: Explicit Indicator Naming v3

**Status**: Draft v3 (Revised based on feedback)
**Date**: 2025-10-13
**Supersedes**: explicit-naming-architecture.md (v2)

---

## Document Updates

**v3 Changes** (based on user feedback):
1. feature_id can use params (e.g., `rsi_14`, `macd_12_26_9`)
2. feature_id is **MANDATORY** and **MUST BE UNIQUE** - no defaults
3. **Breaking change accepted** - migration tool + clear migration path
4. SMA/EMA transformation belongs in indicator/fuzzy layer (not training)
5. Validation is **strict** by default
6. MACD currently fuzzifies main line only (preserve this behavior)

---

## Problem Statement

[Previous problem statement remains - see explicit-naming-architecture.md]

Key addition: **Current system cannot safely default feature_ids when multiple instances of same indicator exist.**

---

## Design Decision: Three Distinct Concepts

### 1. Indicator Type

**What**: The class/category of indicator

**Where**: `type` field in strategy YAML

**Examples**: `"rsi"`, `"ema"`, `"macd"`

### 2. Column Name (Implementation Detail)

**What**: Technical identifier in pandas DataFrame

**Where**: Auto-generated by `get_column_name()`

**Examples**: `"rsi_14"`, `"ema_20"`, `"MACD_12_26"`

**Note**: Remains implementation detail, may vary by indicator

### 3. Feature ID (User-Facing Identifier)

**What**: Stable, unique identifier for fuzzy sets and features

**Where**: `feature_id` field in strategy YAML (**REQUIRED**)

**Examples**:
- `"rsi_14"` (using params for distinction)
- `"rsi_fast"` (descriptive name)
- `"macd_standard"` (semantic name)
- `"macd_12_26_9"` (explicit params)

**Rules**:
- **MANDATORY** - no defaults
- **MUST BE UNIQUE** within strategy
- **CAN use params** for distinction (recommended for clarity)
- **CAN be descriptive** (optional for readability)

---

## Architectural Solution: Feature ID Aliasing

### Core Concept

Indicators produce **technical column names** (implementation detail).

IndicatorEngine creates **feature_id aliases** (user-facing stable names).

Both exist in DataFrame, fuzzy sets reference feature_ids.

```
Strategy Config          Indicator Computation         Feature Mapping
    ↓                            ↓                            ↓
type: "rsi"             compute() produces         Create alias:
feature_id: "rsi_14"    column "rsi_14"           "rsi_14" → same data
period: 14                                        (both columns present)
```

### Data Flow

```
1. Config Loading & Validation
   indicators:
     - type: "rsi"
       feature_id: "rsi_14"  # REQUIRED, validated unique
       period: 14

2. Indicator Instantiation
   rsi = RSI(period=14)
   column_name = "rsi_14"  # Auto-generated

3. Feature ID Mapping
   IndicatorEngine tracks:
   feature_id_map["rsi_14"] = "rsi_14"  # In this case, identical

4. DataFrame Production
   result["rsi_14"] = computed_values  # Technical name
   # If feature_id != column_name, add alias:
   result["rsi_fast"] = computed_values  # User-facing alias

5. Fuzzy Processing
   fuzzy_sets:
     rsi_14:  # References feature_id (stable!)
       oversold: [0, 20, 40]
```

---

## Feature ID Naming Conventions

### Recommended Patterns

**Pattern 1: Use Parameters** (Recommended for clarity)
```yaml
indicators:
  - type: "rsi"
    feature_id: "rsi_14"  # Includes period
    period: 14

  - type: "rsi"
    feature_id: "rsi_21"  # Different period
    period: 21

  - type: "macd"
    feature_id: "macd_12_26_9"  # All params
    fast_period: 12
    slow_period: 26
    signal_period: 9
```

**Pattern 2: Semantic Names** (Recommended for readability)
```yaml
indicators:
  - type: "rsi"
    feature_id: "rsi_fast"  # Descriptive
    period: 7

  - type: "rsi"
    feature_id: "rsi_slow"  # Descriptive
    period: 21

  - type: "macd"
    feature_id: "macd_standard"  # Semantic
    fast_period: 12
    slow_period: 26
    signal_period: 9
```

**Pattern 3: Mixed** (Most common in practice)
```yaml
indicators:
  - type: "rsi"
    feature_id: "rsi_14"  # Param-based
    period: 14

  - type: "macd"
    feature_id: "macd_trend"  # Semantic
    fast_period: 12
    slow_period: 26
    signal_period: 9

  - type: "ema"
    feature_id: "ema_short"  # Semantic
    period: 9
```

### Validation Rules

**Format**: `^[a-zA-Z][a-zA-Z0-9_-]*$`
- Must start with letter
- Can contain: letters, numbers, underscore, dash
- Cannot start with number or special character

**Reserved Words** (blocked):
- `open`, `high`, `low`, `close`, `volume`
- These are price data columns

**Uniqueness**: Enforced - duplicate feature_ids rejected

---

## Migration Strategy: Breaking Change with Migration Tool

### Decision: Breaking Change Accepted

**Rationale**:

1. **Safety**: Cannot safely default feature_ids when multiple instances exist
2. **Clarity**: Forces explicit, unambiguous configuration
3. **Correctness**: Prevents silent bugs from name collisions
4. **Migration**: Tooling makes transition straightforward

### The Danger of Defaults

```yaml
# WITHOUT REQUIRED feature_id (DANGEROUS!):
indicators:
  - type: "rsi"
    period: 7
    # feature_id defaults to "rsi" ???

  - type: "rsi"
    period: 21
    # feature_id defaults to "rsi" ???
    # COLLISION! Which one does fuzzy_sets.rsi reference?

fuzzy_sets:
  rsi:  # AMBIGUOUS! Which RSI period?
    oversold: [0, 20, 40]
```

**Result**: Silent bugs, wrong indicator fuzzified, training uses wrong features.

### Migration Process

#### Step 1: Migration Tool

**Purpose**: Automatically generate feature_ids from current column names

```bash
# Preview migration (dry-run)
python scripts/migrate_to_feature_ids.py strategy.yaml --dry-run

# Migrate single strategy
python scripts/migrate_to_feature_ids.py strategy.yaml

# Migrate all strategies
python scripts/migrate_to_feature_ids.py strategies/*.yaml
```

**Migration Logic**:
1. For each indicator config:
   - Instantiate indicator with params
   - Get column name: `indicator.get_column_name()`
   - Use column name as feature_id (preserves current fuzzy set keys)
2. Validate uniqueness:
   - If collision detected, fail with clear error
   - User must manually choose distinct feature_ids
3. Update fuzzy_sets keys if needed (usually no change needed)

**Example Migration**:
```yaml
# BEFORE (old format)
indicators:
  - name: "rsi"
    period: 14

fuzzy_sets:
  rsi_14:  # References auto-generated column name
    oversold: [0, 20, 40]

# AFTER (migrated)
indicators:
  - type: "rsi"
    feature_id: "rsi_14"  # ADDED: explicit feature_id
    period: 14

fuzzy_sets:
  rsi_14:  # UNCHANGED: fuzzy set key matches feature_id
    oversold: [0, 20, 40]
```

#### Step 2: Clear Error Messages

When user uploads strategy without feature_ids:

```
❌ Validation Error: Missing required field 'feature_id'

Location: indicators[0]
Field: feature_id

Details:
  - Indicator type: rsi
  - Missing feature_id (REQUIRED since v2.1)

Migration Required:
  This strategy uses the old format. Please migrate using:

  python scripts/migrate_to_feature_ids.py your_strategy.yaml

  Or manually add 'feature_id' to each indicator:

  indicators:
    - type: "rsi"
      feature_id: "rsi_14"  # ADD THIS
      period: 14

For more info: https://docs.ktrdr.io/migration/feature-ids
```

#### Step 3: Documentation

- Migration guide with examples
- Video walkthrough of migration tool
- FAQ addressing common issues
- Before/after strategy examples

---

## Impact on Training Pipeline

### Current Training Complexity

**Lines 277-344**: Single-timeframe indicator calculation (~70 lines)
- Infer indicator type from config name
- Compute indicators
- Map column names to config names (complex prefix matching)
- Apply transformations (SMA/EMA ratios)
- Handle MACD multi-output extraction

**Lines 364-424**: Multi-timeframe indicator calculation (~60 lines)
- Duplicate type inference logic
- Compute per timeframe
- Map column names per timeframe
- Apply transformations per timeframe

**Total**: ~130 lines of complex mapping logic with special cases

### New Training Simplicity

```python
def _calculate_indicators_single_timeframe(
    price_data: pd.DataFrame,
    indicator_configs: list[dict[str, Any]],
) -> pd.DataFrame:
    """Calculate indicators using feature_ids."""

    # Validate configs (enforces feature_id presence and uniqueness)
    validated_configs = [
        IndicatorConfig(**config) for config in indicator_configs
    ]

    # Build engine (creates feature_id aliases)
    indicator_engine = IndicatorEngine(indicators=indicator_configs)

    # Compute indicators (includes feature_id aliases)
    indicator_results = indicator_engine.apply(price_data)

    # Combine with price data
    result = price_data.copy()
    for col in indicator_results.columns:
        if col not in result.columns:
            result[col] = indicator_results[col]

    # Safety: handle inf values
    result = result.replace([np.inf, -np.inf], np.nan).fillna(0.0)

    return result
```

**Total**: ~20 lines, no special cases, no name mapping

**Removed**: ~110 lines of complex logic

---

## SMA/EMA Transformation: Architectural Decision

### Current Behavior

Training pipeline transforms SMA/EMA to price ratios:

```python
if indicator_type in ["SMA", "EMA"]:
    # Transform to ratio: price / moving_average
    mapped_results[name] = price_data["close"] / indicator_results[col]
```

**Purpose**: Normalize unbounded price values for fuzzification

**Result**: Fuzzy sets reference relative position (1.0 = at MA, 1.05 = 5% above, etc.)

### User Insight

> "The purpose is to have a normalized value, since fuzzification doesn't know how to deal with unbound values like prices. I'd say it's a property of indicator/fuzzy system, not so much training as it will also be relevant in backtesting and later trading."

### Architectural Options

#### Option A: Keep in Training (Current)

**Pros**: Minimal change, preserves behavior
**Cons**:
- Transformation logic duplicated (training, backtesting, live trading)
- Not reusable, tight coupling
- Transformation hidden from user
- Poor separation of concerns

#### Option B: Move to Indicator Definition

**Create new indicator types**:
```python
class SMADistanceRatio(BaseIndicator):
    """SMA with built-in ratio transformation."""

    def compute(self, data: pd.DataFrame) -> pd.Series:
        sma = data[self.source].rolling(self.period).mean()
        ratio = data[self.source] / sma
        return ratio  # Already normalized!
```

**Usage**:
```yaml
indicators:
  - type: "sma_distance_ratio"  # New indicator type
    feature_id: "sma_ratio_20"
    period: 20
```

**Pros**:
- Clean separation: indicator handles its own normalization
- Reusable across training, backtesting, live trading
- Explicit in configuration
- No special-case logic in training

**Cons**:
- Requires new indicator implementations
- Users must explicitly choose ratio vs absolute
- More indicator types to maintain

#### Option C: Transformation Layer Between Indicators and Fuzzy

**Create transformation system**:
```yaml
indicators:
  - type: "sma"
    feature_id: "sma_20"
    period: 20

transformations:
  sma_20:
    type: "price_ratio"  # Transform before fuzzification
    reference: "close"

fuzzy_sets:
  sma_20:  # References transformed values
    below: [0.93, 0.97, 1.00]
```

**Pros**:
- Explicit transformation step
- Flexible: different transformations possible
- User controls transformation

**Cons**:
- More complex configuration
- Another layer to understand
- Over-engineering for current needs

### Recommendation: Option B (New Indicator Types)

**Rationale**:

1. **Proper Architecture**: Indicator is responsible for its output format
2. **Reusable**: Works in training, backtesting, live trading
3. **Explicit**: User configuration shows transformation clearly
4. **Extensible**: Can add other normalized indicators later
5. **User Feedback**: "I favor proper architecture over minimal change!"

**Implementation Plan**:

1. Create new indicator types:
   - `SMADistanceRatio` (price / SMA)
   - `EMADistanceRatio` (price / EMA)
   - Keep original `SMA` and `EMA` for absolute values

2. Update strategy configs:
   ```yaml
   # OLD (implicit transformation in training)
   - type: "sma"
     feature_id: "sma_20"
     period: 20

   # NEW (explicit in indicator type)
   - type: "sma_distance_ratio"
     feature_id: "sma_ratio_20"
     period: 20
     source: "close"
   ```

3. Migration tool handles this:
   - Detects SMA/EMA in old configs
   - Converts to `_distance_ratio` types
   - Updates fuzzy set keys if needed

4. Remove transformation logic from training pipeline

**Benefit**: Training pipeline simplifies further (~20 more lines removed)

---

## Multi-Output Indicators (MACD)

### Current Behavior

MACD produces 3 outputs:

```python
# MACD compute() returns DataFrame:
result = pd.DataFrame({
    "MACD_12_26": macd_line,      # Main line
    "MACD_signal_12_26_9": signal_line,
    "MACD_hist_12_26_9": histogram
})
```

**Current fuzzy usage** (from mtf_forex_neural.yaml):
```yaml
fuzzy_sets:
  macd_12_26_9:  # References main MACD line
    strong_bearish: [-100, -50, -10]
    bearish: [-20, -5, 0]
    neutral: [-5, 0, 5]
    bullish: [0, 5, 20]
    strong_bullish: [10, 50, 100]
```

**Training pipeline currently**:
- Extracts main line only (filters out "_signal_" and "_hist_")
- Maps to config name for fuzzy matching

### Design Decision: Primary Output Mapping

**Concept**: Multi-output indicators designate **primary output** for feature_id mapping.

**Implementation**:

1. MACD already produces column names with clear pattern
2. Primary output = column without "_signal_" or "_hist_" suffix
3. feature_id maps to primary output
4. Secondary outputs remain accessible via column names

**Configuration**:
```yaml
indicators:
  - type: "macd"
    feature_id: "macd_12_26_9"
    fast_period: 12
    slow_period: 26
    signal_period: 9
```

**DataFrame result**:
```python
# Technical columns (implementation detail)
result["MACD_12_26"] = macd_line         # Primary output
result["MACD_signal_12_26_9"] = signal
result["MACD_hist_12_26_9"] = histogram

# Feature ID alias (user-facing)
result["macd_12_26_9"] = macd_line  # References primary output
```

**Fuzzy sets**:
```yaml
fuzzy_sets:
  macd_12_26_9:  # References feature_id → primary output
    bullish: [0, 5, 20]
```

**User Question**:
> "How does fuzzification of MACD work today? On the main line?"

**Answer**: Yes, currently only main line is fuzzified. Signal and histogram are not currently used in fuzzy sets but remain available if needed in future.

**Future Extension** (not required now):

If user wants to fuzzify secondary outputs:

```yaml
indicators:
  - type: "macd"
    feature_id: "macd_12_26_9"
    fast_period: 12
    slow_period: 26
    signal_period: 9

fuzzy_sets:
  macd_12_26_9:  # Primary output (main line)
    bullish: [0, 5, 20]

  # FUTURE: Could add explicit secondary output references
  # (Not implementing now - over-engineering)
```

**Decision**: Keep current behavior (primary output only), preserve simplicity.

---

## Validation Strategy

### Validation Levels

#### Level 1: Schema Validation (Pydantic)

**What**: Field presence, types, format

**When**: Config load

**Rules**:
- `type` field: REQUIRED
- `feature_id` field: REQUIRED
- `feature_id` format: Must match `^[a-zA-Z][a-zA-Z0-9_-]*$`
- `feature_id` reserved words: Blocked (`open`, `high`, `low`, `close`, `volume`)

#### Level 2: Semantic Validation (StrategyValidator)

**What**: Uniqueness, completeness, consistency

**When**: After config load, before execution

**Rules**:
- feature_id uniqueness: No duplicates
- feature_id completeness: Every indicator has feature_id
- fuzzy set matching: Every feature_id has fuzzy_sets entry (STRICT)

**Strictness**: STRICT by default

```python
# Validate fuzzy set matching
feature_ids = {config.feature_id for config in indicators}
fuzzy_keys = set(fuzzy_sets.keys())

missing = feature_ids - fuzzy_keys
if missing:
    raise ValidationError(
        f"Indicators missing fuzzy_sets: {missing}. "
        f"Add fuzzy_sets entries for these feature_ids."
    )

orphans = fuzzy_keys - feature_ids
if orphans:
    # WARNING only (fuzzy sets might be for derived features)
    logger.warning(f"Fuzzy sets without indicators: {orphans}")
```

#### Level 3: Runtime Validation

**What**: Indicator instantiation, computation

**When**: During indicator engine execution

**Rules**:
- Indicator parameters valid
- Sufficient data for computation
- feature_id aliases created correctly

### Validation Error Format

**Requirements**:
1. Error message (what's wrong)
2. Error code (machine-readable)
3. Context (where: file, section, field)
4. Details (structured data)
5. Suggestion (how to fix)

**Example**:
```python
raise ConfigurationError(
    message="Indicator missing required field 'feature_id'",
    error_code="STRATEGY-MissingFeatureId",
    context={
        "file": "strategy.yaml",
        "section": "indicators",
        "index": 0,
        "indicator_type": "rsi"
    },
    details={
        "indicator": {"type": "rsi", "period": 14},
        "missing_field": "feature_id"
    },
    suggestion=(
        "Add 'feature_id' to indicator:\n\n"
        "indicators:\n"
        "  - type: \"rsi\"\n"
        "    feature_id: \"rsi_14\"  # ADD THIS\n"
        "    period: 14\n\n"
        "Or run migration tool:\n"
        "  python scripts/migrate_to_feature_ids.py strategy.yaml"
    )
)
```

---

## Open Questions & Decisions

### ✅ Q1: SMA/EMA Transformation - RESOLVED

**Decision**: Input transformation in fuzzy configuration

**Rationale**: Transformation is a property of **how to fuzzify** a moving average, not the indicator itself. It belongs in the fuzzy realm.

**Architecture**: Add `input_transform` specification to fuzzy set configuration:

```yaml
indicators:
  - type: "sma"
    feature_id: "sma_20"
    period: 20

fuzzy_sets:
  sma_20:
    input_transform:  # NEW: How to prepare indicator value for fuzzification
      type: "price_ratio"
      reference: "close"  # close / sma_value

    # Fuzzy sets operate on transformed value (ratio)
    below: {type: "triangular", parameters: [0.93, 0.97, 1.00]}
    at_ma: {type: "triangular", parameters: [0.98, 1.00, 1.02]}
    above: {type: "triangular", parameters: [1.00, 1.03, 1.07]}
```

**Data Flow**:
1. Indicator computes SMA → absolute value (e.g., 150.25)
2. Fuzzy system reads `input_transform`
3. Applies transformation: `close / sma_value` → ratio (e.g., 1.02)
4. Fuzzifies transformed value with membership functions

**Benefits**:
- Proper separation of concerns (indicator computes, fuzzy transforms+fuzzifies)
- Reusable across training, backtesting, live trading
- Explicit in configuration (user sees transformation)
- No special case logic in training pipeline
- Extensible to other transformations (log scale, z-score, etc.)

### ✅ Q2: MACD Multi-Output - RESOLVED

**Decision**: feature_id maps to primary output (main line), preserve current behavior

**Rationale**: Current system already works this way, no need for complexity

### ✅ Q3: Validation Strictness - RESOLVED

**Decision**: STRICT by default (all feature_ids must have fuzzy_sets)

**Rationale**: Catch errors early, clear expectations

### ✅ Q4: Backward Compatibility - RESOLVED

**Decision**: BREAKING CHANGE with migration tool

**Rationale**: Cannot safely default feature_ids with multiple instances

### ✅ Q5: feature_id Naming - RESOLVED

**Decision**: Allow params in feature_id (e.g., `rsi_14`, `macd_12_26_9`)

**Rationale**: Clearest, most explicit, matches current column names

---

## Success Criteria

### Technical Success

1. ✅ feature_id REQUIRED and UNIQUE (no ambiguity)
2. ✅ Training pipeline simplified (~130 lines removed)
3. ✅ Early validation (before computation)
4. ✅ Clear error messages (message, code, context, suggestion)
5. ✅ No test breakage (indicators unchanged)
6. ✅ Transformation architecture clean (input_transform in fuzzy config)

### User Experience Success

1. ✅ Migration tool works (automated, validated)
2. ✅ Clear migration guide (docs, examples, videos)
3. ✅ Error messages actionable (include migration command)
4. ✅ Obvious configuration (feature_ids explicit)

### Maintainability Success

1. ✅ Simpler training code (~130 lines removed)
2. ✅ Clear separation (indicator → feature_id → fuzzy with transform)
3. ✅ Reusable transformations (fuzzy input_transform)
4. ✅ Testable (each phase independent)

---

## Summary of Architectural Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| **feature_id requirement** | MANDATORY | Prevents ambiguity with multiple instances |
| **feature_id uniqueness** | ENFORCED | No collisions, clear references |
| **feature_id format** | Can use params | Explicit, matches column names |
| **Backward compatibility** | BREAKING CHANGE | No safe default possible |
| **Migration** | Automated tool | Straightforward transition |
| **SMA/EMA transformation** | Input transform in fuzzy config | Proper separation, fuzzy realm |
| **MACD multi-output** | Primary output only | Preserve current behavior |
| **Validation strictness** | STRICT | Catch errors early |
| **Training simplification** | ~130 lines removed | Simpler, no special cases |

---

## Next Steps

1. **Review Architecture** - Confirm decisions align with vision
2. **Create Implementation Plan** - Phased approach with validation
3. **Build Migration Tool** - Automated strategy migration
4. **Implement Phase 0** - Fix error reporting infrastructure
5. **Implement Phase 1** - Add feature_id support
6. **Implement Phase 2** - IndicatorEngine aliasing
7. **Implement Phase 3** - Training pipeline simplification
8. **Implement Input Transforms** - Add input_transform to fuzzy config system
9. **Documentation** - Migration guide, examples, videos
10. **Testing** - Comprehensive validation at each phase

---

**END OF ARCHITECTURE DOCUMENT v3**
