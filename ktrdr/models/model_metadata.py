"""Model metadata for v3 strategy training.

This module provides the ModelMetadata class for storing v3 model information,
including the critical resolved_features list that defines canonical feature order.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Optional

from ktrdr import get_logger

logger = get_logger(__name__)


@dataclass
class ModelMetadata:
    """Metadata for v3-trained models.

    This dataclass stores v3-specific model information, including the critical
    `resolved_features` list that defines the canonical feature order for backtest.

    The resolved_features list is the source of truth:
    - Generated by FeatureResolver during training
    - Stored here with the trained model
    - Used by backtest to ensure feature order matches training

    Attributes:
        model_name: Unique identifier for this model
        strategy_name: Name of the v3 strategy used for training
        created_at: When the model was created (defaults to now)
        strategy_version: Version string, should be "3.0" for v3 models
        indicators: Serialized indicator definitions from strategy config
        fuzzy_sets: Serialized fuzzy set definitions from strategy config
        nn_inputs: Serialized nn_inputs specifications from strategy config
        resolved_features: CRITICAL - ordered list of feature IDs
        training_symbols: Symbols used during training
        training_timeframes: Timeframes used during training
        training_metrics: Training metrics (loss, accuracy, etc.)
    """

    # Identity
    model_name: str
    strategy_name: str
    created_at: Optional[datetime] = None

    # Version info
    strategy_version: str = "3.0"

    # V3-specific: full config for reproducibility
    indicators: dict[str, dict[str, Any]] = field(default_factory=dict)
    fuzzy_sets: dict[str, dict[str, Any]] = field(default_factory=dict)
    nn_inputs: list[dict[str, Any]] = field(default_factory=list)

    # CRITICAL: ordered feature list (source of truth for backtest)
    resolved_features: list[str] = field(default_factory=list)

    # Training context
    training_symbols: list[str] = field(default_factory=list)
    training_timeframes: list[str] = field(default_factory=list)
    training_metrics: dict[str, float] = field(default_factory=dict)

    def __post_init__(self):
        """Initialize default values."""
        if self.created_at is None:
            from datetime import timezone

            self.created_at = datetime.now(timezone.utc)

    def to_dict(self) -> dict[str, Any]:
        """Serialize to dict for JSON storage.

        Returns:
            Dictionary with all fields, datetime converted to ISO string
        """
        return {
            "model_name": self.model_name,
            "strategy_name": self.strategy_name,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "strategy_version": self.strategy_version,
            "indicators": self.indicators,
            "fuzzy_sets": self.fuzzy_sets,
            "nn_inputs": self.nn_inputs,
            "resolved_features": self.resolved_features,
            "training_symbols": self.training_symbols,
            "training_timeframes": self.training_timeframes,
            "training_metrics": self.training_metrics,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "ModelMetadata":
        """Deserialize from dict.

        Args:
            data: Dictionary with metadata fields

        Returns:
            ModelMetadata instance
        """
        # Parse datetime
        created_at = data.get("created_at")
        if created_at is not None and isinstance(created_at, str):
            created_at = datetime.fromisoformat(created_at)

        return cls(
            model_name=data["model_name"],
            strategy_name=data["strategy_name"],
            created_at=created_at,
            strategy_version=data.get("strategy_version", "3.0"),
            indicators=data.get("indicators", {}),
            fuzzy_sets=data.get("fuzzy_sets", {}),
            nn_inputs=data.get("nn_inputs", []),
            resolved_features=data.get("resolved_features", []),
            training_symbols=data.get("training_symbols", []),
            training_timeframes=data.get("training_timeframes", []),
            training_metrics=data.get("training_metrics", {}),
        )


# Backwards compatibility alias
ModelMetadataV3 = ModelMetadata
